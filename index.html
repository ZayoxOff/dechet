<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Megabonk - Prototype Clone</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Inter,Arial}
  #gameWrap{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
  canvas{background:#0b0b10;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,0.6)}
  #ui{width:320px;display:flex;flex-direction:column;gap:8px}
  .card{background:linear-gradient(180deg,#121217,#0d0d10);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
  h1{margin:0;font-size:18px}
  #log{height:260px;overflow:auto;font-size:13px}
  button{padding:8px;border-radius:6px;border:none;background:#1e90ff;color:white;cursor:pointer}
  .small{font-size:13px;color:#9aa}
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game" width="960" height="640"></canvas>
  <div id="ui">
    <div class="card">
      <h1>Megabonk - Prototype Clone</h1>
      <div class="small">Contrôles: ZQSD / WASD / flèches, souris vise, clic tir, E ramasser</div>
    </div>

    <div class="card">
      <div><strong>Stats</strong></div>
      <div id="stats">HP: 100 | XP: 0 | Level: 1 | Gold: 0</div>
      <div style="margin-top:8px;">
        <button id="startBtn">Start / Restart</button>
        <button id="spawnWave">Spawn Wave</button>
      </div>
    </div>

    <div class="card">
      <div><strong>Upgrades aléatoires (appuyer pour appliquer à level up)</strong></div>
      <div id="upgrades" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <div><strong>Log</strong></div>
      <div id="log"></div>
    </div>
  </div>
</div>

<script>
/* ------------------
   Utility & Settings
   ------------------ */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const rand = (a,b)=>a + Math.random()*(b-a);
const randInt = (a,b)=>Math.floor(rand(a,b+1));

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

const logEl = document.getElementById('log');
function log(s){ const p = document.createElement('div'); p.textContent = s; logEl.prepend(p); }

/* ------------------
   Game State
   ------------------ */
let state = {
  running: false,
  player: null,
  bullets: [],
  enemies: [],
  pickups: [],
  wave: 0,
  time: 0,
  particles: []
};

/* ------------------
   Player & Entities
   ------------------ */
class Entity {
  constructor(x,y,r=12){ this.x=x; this.y=y; this.r=r; this.vx=0; this.vy=0; this.dead=false; }
  distTo(o){ const dx=this.x-o.x,dy=this.y-o.y; return Math.hypot(dx,dy); }
}
class Player extends Entity {
  constructor(x,y){
    super(x,y,14);
    this.hp = 100;
    this.maxHp = 100;
    this.xp = 0;
    this.level = 1;
    this.gold = 0;
    this.speed = 180; // px/sec
    this.fireRate = 6; // shots/sec
    this.fireTimer = 0;
    this.damage = 12;
    this.size = 14;
    this.slow = false;
  }
  tryFire(dt, aimX, aimY, mouseDown){
    this.fireTimer -= dt;
    if(mouseDown && this.fireTimer<=0){
      this.fireTimer = 1/this.fireRate;
      const ang = Math.atan2(aimY-this.y, aimX-this.x);
      const speed = 420;
      const b = new Bullet(this.x + Math.cos(ang)* (this.size+6), this.y + Math.sin(ang)*(this.size+6), Math.cos(ang)*speed, Math.sin(ang)*speed, this.damage);
      state.bullets.push(b);
      spawnParticle(this.x,this.y,ang,4);
    }
  }
}
class Bullet extends Entity {
  constructor(x,y,vx,vy,dmg){ super(x,y,4); this.vx=vx; this.vy=vy; this.dmg=dmg; this.life=2; }
}
class Enemy extends Entity {
  constructor(x,y,kind=0){
    super(x,y,12);
    this.kind = kind;
    this.hp = 20 + kind*10;
    this.speed = 60 + kind*5;
    this.damage = 8 + kind*3;
    this.value = 5 + kind*3;
  }
}

/* ------------------
   Particles & pickups
   ------------------ */
function spawnParticle(x,y,ang,count=8){
  for(let i=0;i<count;i++){
    const sp = {x,y,vx:Math.cos(ang+rand(-1,1))*rand(40,280), vy:Math.sin(ang+rand(-1,1))*rand(40,280), life:rand(0.3,0.9), t:0, r:rand(1,3)};
    state.particles.push(sp);
  }
}
class Pickup extends Entity {
  constructor(x,y,type,amt){ super(x,y,8); this.type=type; this.amt=amt; }
}

/* ------------------
   Input
   ------------------ */
const input = {up:false,down:false,left:false,right:false,mouseX:0,mouseY:0,mouseDown:false};
window.addEventListener('keydown', e=>{
  if(e.key==='w' || e.key==='z' || e.key==='ArrowUp') input.up=true;
  if(e.key==='s' || e.key==='ArrowDown') input.down=true;
  if(e.key==='a' || e.key==='q' || e.key==='ArrowLeft') input.left=true;
  if(e.key==='d' || e.key==='ArrowRight') input.right=true;
  if(e.key==='e') pickupNearby();
});
window.addEventListener('keyup', e=>{
  if(e.key==='w' || e.key==='z' || e.key==='ArrowUp') input.up=false;
  if(e.key==='s' || e.key==='ArrowDown') input.down=false;
  if(e.key==='a' || e.key==='q' || e.key==='ArrowLeft') input.left=false;
  if(e.key==='d' || e.key==='ArrowRight') input.right=false;
});
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  input.mouseX = (e.clientX - rect.left) * (canvas.width/rect.width);
  input.mouseY = (e.clientY - rect.top) * (canvas.height/rect.height);
});
canvas.addEventListener('mousedown', ()=>input.mouseDown=true);
window.addEventListener('mouseup', ()=>input.mouseDown=false);

/* ------------------
   Game Logic
   ------------------ */
function startGame(){
  state.running = true;
  state.enemies = [];
  state.bullets = [];
  state.pickups = [];
  state.particles = [];
  state.wave = 0;
  state.time = 0;
  const p = new Player(W/2,H/2);
  state.player = p;
  log('Nouvelle partie: bon courage !');
  spawnWave();
  updateUI();
}

function spawnWave(){
  state.wave++;
  const count = 6 + state.wave*2 + randInt(0,4);
  for(let i=0;i<count;i++){
    const side = randInt(0,3);
    let x,y;
    if(side===0){ x = rand(-40, -10); y = rand(-40, H+40); }
    else if(side===1){ x = rand(W+10, W+40); y = rand(-40, H+40); }
    else if(side===2){ x = rand(-40, W+40); y = rand(-40, -10); }
    else { x = rand(-40, W+40); y = rand(H+10, H+40); }
    const kind = Math.min(3, Math.floor(state.wave/3) + (Math.random()<0.2?1:0));
    state.enemies.push(new Enemy(x,y,kind));
  }
  log('Vague ' + state.wave + ' : ' + count + ' ennemis.');
  updateUI();
}

/* Player pickup */
function pickupNearby(){
  if(!state.player) return;
  for(let i=state.pickups.length-1;i>=0;i--){
    const pk = state.pickups[i];
    if(state.player.distTo(pk) < 28){
      if(pk.type==='hp'){ state.player.hp = Math.min(state.player.maxHp, state.player.hp + pk.amt); log('Soins +' + pk.amt); }
      else if(pk.type==='gold'){ state.player.gold += pk.amt; log('Gold +' + pk.amt); }
      else if(pk.type==='xp'){ gainXP(pk.amt); }
      state.pickups.splice(i,1);
      updateUI();
    }
  }
}

function gainXP(v){
  state.player.xp += v;
  log('XP +' + v);
  const needed = 10 + state.player.level*10;
  if(state.player.xp >= needed){
    state.player.xp -= needed;
    state.player.level++;
    showUpgradeChoices();
    log('Level up ! Niveau ' + state.player.level);
  }
  updateUI();
}

/* Upgrades pool and UI */
const upgradePool = [
  {id:'hpmax',txt:'+max HP 20', apply: p=>{ p.maxHp += 20; p.hp += 20 }},
  {id:'dmg',txt:'+dégâts +4', apply: p=> p.damage += 4},
  {id:'firerate',txt:'+cadence +1', apply: p=> p.fireRate += 1},
  {id:'speed',txt:'+vitesse +30', apply: p=> p.speed += 30},
  {id:'heal',txt:'Soin instant +30', apply: p=> p.hp = Math.min(p.maxHp, p.hp + 30)},
  {id:'gold',txt:'+gold +20', apply: p=> p.gold += 20}
];

function showUpgradeChoices(){
  const el = document.getElementById('upgrades');
  el.innerHTML = '';
  // choose three random distinct upgrades
  const choices = [];
  while(choices.length < 3){
    const cand = upgradePool[randInt(0, upgradePool.length-1)];
    if(!choices.includes(cand)) choices.push(cand);
  }
  choices.forEach(u=>{
    const b = document.createElement('button');
    b.textContent = u.txt;
    b.style.display='block';
    b.style.marginTop='6px';
    b.onclick = ()=>{
      u.apply(state.player);
      document.getElementById('upgrades').innerHTML='';
      updateUI();
      log('Upgrade appliqué: ' + u.txt);
    };
    el.appendChild(b);
  });
}

/* ------------------
   Update Loop
   ------------------ */
let last = performance.now();
function step(now){
  const dt = Math.min(0.05, (now-last)/1000);
  last = now;
  if(state.running) update(dt);
  render();
  requestAnimationFrame(step);
}
requestAnimationFrame(step);

function update(dt){
  state.time += dt;

  const p = state.player;
  // movement
  let mx = 0, my = 0;
  if(input.up) my -= 1;
  if(input.down) my += 1;
  if(input.left) mx -= 1;
  if(input.right) mx += 1;
  const mag = Math.hypot(mx,my);
  if(mag>0){ mx/=mag; my/=mag; }
  p.x += mx * p.speed * dt;
  p.y += my * p.speed * dt;
  p.x = clamp(p.x, 12, W-12);
  p.y = clamp(p.y, 12, H-12);

  // firing
  p.tryFire(dt, input.mouseX, input.mouseY, input.mouseDown);

  // bullets
  for(let i=state.bullets.length-1;i>=0;i--){
    const b = state.bullets[i];
    b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
    if(b.life <= 0 || b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) state.bullets.splice(i,1);
  }

  // enemies AI
  for(let i=state.enemies.length-1;i>=0;i--){
    const e = state.enemies[i];
    // simple seek
    const dx = p.x - e.x, dy = p.y - e.y;
    const d = Math.hypot(dx,dy) + 0.0001;
    e.vx = (dx/d) * e.speed;
    e.vy = (dy/d) * e.speed;
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    // collision with bullets
    for(let j=state.bullets.length-1;j>=0;j--){
      const b = state.bullets[j];
      if(e.distTo(b) < e.r + b.r){
        e.hp -= b.dmg;
        spawnParticle(b.x,b.y,Math.atan2(b.vy,b.vx),6);
        state.bullets.splice(j,1);
        if(e.hp <= 0){
          // dead
          spawnParticle(e.x,e.y,Math.random()*Math.PI*2,16);
          state.pickups.push(new Pickup(e.x,e.y, Math.random()<0.25?'hp':'gold', Math.random()<0.25?15:randInt(5,12)));
          gainXP(e.value);
          state.enemies.splice(i,1);
          break;
        }
      }
    }
    // touch player
    if(e && e.distTo(p) < e.r + p.r){
      p.hp -= e.damage * dt; // continuous damage on touch
      if(Math.random()<0.1) spawnParticle(e.x,e.y,Math.random()*6.28,3);
      if(p.hp <= 0){
        p.hp = 0;
        state.running = false;
        log('Tu es mort — appuie Start pour recommencer.');
      }
    }
  }

  // pickups tick (floating)
  for(const pk of state.pickups){
    pk.y += Math.sin(state.time*2 + pk.x)*0.2;
  }

  // particles
  for(let i=state.particles.length-1;i>=0;i--){
    const q = state.particles[i];
    q.x += q.vx*dt; q.y += q.vy*dt; q.vy += 300*dt; q.t += dt;
    if(q.t > q.life) state.particles.splice(i,1);
  }

  // auto spawn next wave if area clear
  if(state.running && state.enemies.length === 0 && state.time > 1){
    // small delay
    setTimeout(()=>{ if(state.enemies.length===0 && state.running) spawnWave(); }, 600);
  }

  updateUI();
}

/* ------------------
   Rendering
   ------------------ */
function render(){
  // background
  ctx.clearRect(0,0,W,H);
  // grid
  ctx.save();
  ctx.globalAlpha = 0.06;
  for(let x=0;x<W;x+=40){ ctx.fillStyle='#0f0f12'; ctx.fillRect(x,0,1,H); }
  for(let y=0;y<H;y+=40){ ctx.fillStyle='#0f0f12'; ctx.fillRect(0,y,W,1); }
  ctx.restore();

  // pickups
  for(const pk of state.pickups){
    ctx.save();
    ctx.translate(pk.x, pk.y);
    if(pk.type==='hp'){
      ctx.fillStyle='#f66';
      ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='white'; ctx.fillRect(-2,-6,4,12);
      ctx.fillRect(-6,-2,12,4);
    } else {
      ctx.fillStyle='#ffde59';
      ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // particles
  for(const q of state.particles){
    const a = 1 - q.t/q.life;
    ctx.globalAlpha = a;
    ctx.fillStyle = '#fff';
    ctx.fillRect(q.x,q.y,q.r,q.r);
    ctx.globalAlpha = 1;
  }

  // enemies
  for(const e of state.enemies){
    ctx.save();
    ctx.translate(e.x,e.y);
    // body
    ctx.fillStyle = '#c94';
    ctx.beginPath(); ctx.arc(0,0,e.r,0,Math.PI*2); ctx.fill();
    // health bar
    ctx.fillStyle = '#222';
    ctx.fillRect(-e.r, -e.r-8, e.r*2, 4);
    ctx.fillStyle = '#4f4';
    const hpPct = Math.max(0,e.hp) / (20 + e.kind*10);
    ctx.fillRect(-e.r, -e.r-8, e.r*2*hpPct, 4);
    ctx.restore();
  }

  // bullets
  for(const b of state.bullets){
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
  }

  // player with aiming cone
  const p = state.player;
  if(p){
    // aim line
    const ang = Math.atan2(input.mouseY - p.y, input.mouseX - p.x);
    ctx.save();
    ctx.translate(p.x,p.y);
    // shadow
    ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.arc(6,8,p.r+2,0,Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#7fb3ff';
    ctx.arc(0,0,p.r,0,Math.PI*2); ctx.fill();
    // gun direction
    ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(Math.cos(ang)*(p.r+28), Math.sin(ang)*(p.r+28));
    ctx.stroke();
    ctx.restore();

    // HUD crosshair
    ctx.beginPath();
    ctx.strokeStyle='rgba(255,255,255,0.06)';
    ctx.arc(input.mouseX, input.mouseY, 8, 0, Math.PI*2);
    ctx.stroke();
  }

  // overlay text
  ctx.fillStyle='rgba(255,255,255,0.06)';
  ctx.fillRect(8,H-38,260,30);
  ctx.fillStyle='#ddd';
  ctx.font='14px system-ui';
  ctx.fillText(`Vague ${state.wave} — Ennemis: ${state.enemies.length}`, 14, H-18);
}

/* ------------------
   UI helpers
   ------------------ */
function updateUI(){
  const p = state.player;
  if(!p) return;
  document.getElementById('stats').textContent = `HP: ${Math.floor(p.hp)}/${p.maxHp} | XP: ${Math.floor(p.xp)} | Level: ${p.level} | Gold: ${p.gold}`;
}

document.getElementById('startBtn').onclick = startGame;
document.getElementById('spawnWave').onclick = spawnWave;

/* start paused */
log('Prototype prêt. Appuie Start pour jouer !');
</script>
</body>
</html>